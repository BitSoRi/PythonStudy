# 2-5 딕셔너리 
#### Q1 딕셔너리 만들기
다음 표를 딕셔너리로 만드시오.


|항목  |    값 |
----|----
|name  | 홍길동|
|birth |  1128 |
|age   |   30  |


#### A1
```
q_1 = {'name':'홍길동', 'birth':1128, 'age':30}
```


#### Q2 딕셔너리 오류
다음과 같은 딕셔너리 a가 있다.
```
>>> a = dict()
>>> a
{}
```
다음 중 오류가 발생하는 경우는 어떤 경우인가? 그리고 그 이유를 설명하시오.
1. a['name'] = 'python'
2. a[('a',)] = 'python'
3. a[[1]] = 'python'
4. a[250] = 'python'


#### A2
```
q_2 = dict()
q_2['name'] = 'python'
q_2[('a', )] = 'python'
q_2[250] = 'python'
```
list는 key값으로 사용할 수 없다.


#### Q3 딕셔너리 값 추출1
딕셔너리 a에서 'B'에 해당되는 값을 추출하고 삭제해 보자.
```
>>> a = {'A':90, 'B':80, 'C':70}
```


#### A3
```
q_3 = {'A':90, 'B':80, 'C':70}
q_3.pop('B')
```


#### Q4 딕셔너리 값 추출2
다음은 딕셔너리의 a에서 'C'라는 key에 해당되는 value를 출력하는 프로그램이다.
```
>>> a = {'A':90, 'B':80, 'C':70}
>>> a['C']
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
keyError : 'C'
```
a 딕셔너리에는 'C'라는 key가 없으므로 위와 같은 오류가 발생하게 된다. 'C'에 해당되는 키값이 없을 경우 오류 대신 70을 얻을 수 있도록 수정해보자.


#### A4
```
q_4 = {'A':90, 'B':80}
a_4 = q_4.get('C', 70)
```


#### Q5 딕셔너리 최소값
다음과 같은 딕셔너리 a가 있다.
```
>>> a = {'A':90, 'B':80, 'C':70}
```
딕셔너리의 a의 value 중에서 최고 값을 출력하시오.
(힌트. 여러개의 요소값중 최소값을 얻을 수 있는 min함수를 이용해보자.)


#### A5
```
q_5 = {'A':90, 'B':80, 'C':70}
a_5 = min(q_5.values())
```


#### Q6 딕셔너리 리스트 변환
다음과 같은 딕셔너리 a가 있다.
```
>>> a = {'A':90, 'B':80, 'C':70}
```
위 딕셔너리 a를 다음과 같은 리스트로 만들어 보자.
```
[('A', 90), ('B', 80), ('C', 70)]
```
(힌트. 딕셔너리의 items 내장함수를 이용해 보자.)


#### A6
```
q_6 = {'A':90, 'B':80, 'C':70}
a_6 = list(q_6.items())
```


# 2-6 집합 
#### Q1 집합 만들기1
```['a', 'b', 'c']``` 라는 리스트를 집합 자료형으로 만드시오.


#### A1
```

q_1 = ['a', 'b', 'c']
a_1 = set(q_1)
```


#### Q2 집합의 중복
중복을 허용하지 않는 지합 자료형의 특징을 이용하여 다음 a 리스트에서 중복된 숫자들을 제거해 보자.
```
>>> a = [1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5]
```


#### A2
```
q_2 = [1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5]
a_2 = set(q_2)
```


#### Q3 차집합
다음과 같은 2개의 집합 자료형이 있다.
```
>>> s1 = set(['a', 'b', 'c', 'd', 'e'])
>>> s2 = set(['c', 'd', 'e', 'f', 'g'])
```
s1 집합의 항목 중 s2 집합에 포함된 항목을 제거 해 보자.


#### A3
```
q_3_s1 = set(['a', 'b', 'c', 'd', 'e'])
q_3_s2 = set(['c', 'd', 'e', 'f', 'g'])

a_3 = q_3_s1 - q_3_s2
```


#### Q4 집합 만들기 2
집합 자료형은 다음과 같이 만들 수 있다.
```
>>> a = {'a', 'b', 'c'}
>>> a
{'a', 'b', 'c'}
>>> type(a)
<class 'set'>
```
값이 하나도 없는 비어있는 set을 만들기 위해 다음과 같이 시도 해 보자.
```
>>> a = {}
>>> type(a)
<class 'dict'>
```
위와 같이 값이 있을 경우에는 집합 자료형으로 인식했지만 값이 없을 경우에는 딕셔너리로 인식하게 된다. 그렇다면 값이 비어있는 집합 자료형은 어떻게 만들 수 있을 까?


#### A4
```
a_4 = set()
```


#### Q5 집합 추가
다음과 같은 집합 자료형 a가 있다.
```
>>> a = {'a', 'b', 'c'}
```
a 에 ```{'d', 'e', 'f'}``` 를 추가하시오.


#### A5
```
q_5 = {'a', 'b', 'c'}
a_5 = q_5 | {'d', 'e', 'f'}
```


# 2-7 불 자료형
#### Q1 불 자료형과 조건문
다음은 불 자료형을 리턴하는 조건문들이다. 각 각의 예제의 결과가 어떻게 나오는지 예상해 보자.
```
>>> 1 != 1
>>> 3 > 1
>>> 'a' in 'abc'
>>> 'a' not in [1, 2, 3]
```


#### A1
```
1 != 1
3 > 1
'a' in 'abd'
'a' not in [1, 2, 3]

False
True
True
True
```


#### Q2 bool 연산자
bool 연산자를 이용하여 다음 자료형의 참과 거짓을 판별하시오.
```
>>> a = "python"
>>> b = ""
>>> c = (1, 2, 3)
>>> d = 0
```


#### A2
```
a = 'python'
b = ''
c = (1, 2, 3)
d = 0

bool(a)
bool(b)
bool(c)
bool(d)

True
False
True
False
```


# 2-8 자료형의 값을 저장하는 공간, 변수
#### Q1 변수와 객체1
다음 예제를 싱행하고 그 결과를 설명하시오.
```
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
```


#### A1
```
q_1_a = [1, 2, 3]
q_1_b = [1, 2, 3]
q_1_a is q_1_b

False
```


#### Q2 변수와 객체2
다음 예제를 실행하고 그 결과를 설명하시오.
```
>>> a = [1, 2, 3]
>>> b = a
>>> a is b
```


#### A2
```
q_2_a = [1, 2, 3]
q_2_b = q_2_a
q_2_a is q_2_b

True
```


#### Q3 객체의 변경
파이썬은 다음처럼 동일한 값에 여러 개의 변수를 선언할 수 있다. 아래와 같이 a, b 변수를 선언 한 후 a의 첫 번째 요소값을 변경하면 b의 값은 어떻게 될까? 그리고 이런 결과가 나오는 이유에 대해서 설명해 보자.
```
>>> a = b = [1, 2, 3]
>>> a[1] = 4
>>> print(b)
```


#### A3
```
q_3_a = q_3_b = [1, 2, 3]
q_3_a[1] = 4
print(q_3_b)

4
```
같은 주소의 변수이기 때문에 동일하게 변경된다.


#### Q4 리스트 복사1
다음 예제를 실행하고 그 결과를 설명하시오.
```
>>> a = [1, 2, 3]
>>> b = a[:]
>>> a is b
```


#### A4
```
q_4_a = [1, 2, 3]
q_4_b = q_4_a[:]
q_4_a is q_4_b

False
```
리스트의 값만 복사한 것이므로 서로 다른 변수이다.


#### Q5 리스트 복사2
b리스트는 a리스트를 copy하여 다음과 같이 생성하였다.
```
>>> a = [1, 2, 3]
>>> b = a[:]
```
그리고 다음과 같이 a리스트의 두번째 요소 값을 2에서 4로 바꾸었다.
```
>>> a[1] = 4
>>> a
[1, 4, 3]
>>> print(b)
```
이제 b리스트를 출력하면 어떤 값이 출력될까? 그리고 그런 결과값이 나오는 이유에 대해서 설명하시오.


#### A5
```
q_5_a = [1, 2, 3]
q_5_b = q_5_a[:]
q_5_a[1] = 4
print(q_5_b)

[1, 2, 3]
```


#### Q6 리스트의 더하기와 extend
다음과 같은 리스트 a가 있다.
```
>>> a = [1, 2, 3]
```
리스트 a에 ```[4, 5]```를 ```+```기호를 이용하여 더한 결과는 다음과 같다.
```
>>> a = [1, 2, 3]
>>> a = a + [4, 5]
>>> a
[1, 2, 3, 4, 5]
```
```+``` 기로를 이용하여 더한 것과 extend한 것의 차이점이 있을까? 있다면 그 차이점에 대해서 얘기해 보자.


#### A6
```
q_6 = [1, 2, 3]
q_6_1 = q_6 + [4, 5]
q_6.extend([4, 5])
```
```+```를 사용한 것은 새로운 변수로 지정하지만 extend는 기존의 변수가 변한다.


#### Q7 리스트 복사3
a리스트는 리스트내에 ```[2, 3]```이라는 리스트를 하나 더 포함하고 있는 리스트이다. 이 a리스트를 copy하여 b리스트를 다음과 같이 만들었다.
```
>>> a = [1, [2, 3], 4]
>>> b = a[:]
```
그리고 다음과 같이 a 리스트에 포함된 ```[2, 3]```의 첫번째 값을 2에서 5로 바꾸어 주었다. 이렇게 a리스트에 포함된 리스트의 요소값을 변경하면 b리스트는 어떻게 될까? 그리고 그런 결과값이 나오는 이유에 대해서 설명하시오.
```
>>> a[1][0] = 5
>>> a
[1, [5, 3], 4]
>>> print(b)
```


#### A7
```
q_7_a = [1, [2, 3], 4]
q_7_b = q_7_a[:]

q_7_a[1][0] = 5
q_7_a
print(q_7_b)

[1, [5, 3], 4]
```
list의 주소값을 복사한 것이므로 a의 내부에 있는 list 값이 바뀌면 b의 내부에 있는 list 값도 같이 바뀐다.
